import z3
from IPython import embed

class State:
    def __init__(self):
        self.state = [0]*0x270
        self.index = 0

def mag(i):
    return z3.If(i == 0, z3.BitVecVal(0x0, 32), z3.BitVecVal(0x9908b0df, 32))

def m_seedRand(s, i):
    s.state[0] = i & 0xffffffff
    s.index = 1
    while  s.index < 0x270:
        s.state[s.index] = (s.state[s.index -1] * 0x17b5) & 0xffffffff
        s.index = s.index + 1
    return s


def gerRandLong(s):
    if 0x26f < s.index or s.index < 0:
        if 0x270 < s.index or s.index < 0: 
            m_seedRand(s,0x1105)
        
        for i in range(0xe3):
            p1 = s.state[i + 0x18d]
            p2 = z3.LShR(((s.state[i + 1] & 0x7fffffff) | (s.state[i] & 0x80000000)), 1)
            p3 = mag(s.state[i + 1] & 1)
            s.state[i] = (p1 ^ p2 ^ p3) & 0xffffffff

        for i in range(0xe3, 0x26f):
            p1 = s.state[i - 0xe3]
            p2 = z3.LShR(((s.state[i + 1] & 0x7fffffff) | (s.state[i] & 0x80000000)), 1)
            p3 = mag(s.state[i + 1] & 1)
            s.state[i] = (p1 ^ p2 ^ p3) & 0xffffffff

        p1 = s.state[0x18c]
        p2 = z3.LShR(((s.state[i + 1] & 0x7fffffff) | (s.state[0x26f] & 0x80000000)), 1)
        p3 = mag(s.state[0] & 1)
        s.state[0x26f] = (p1 ^ p2 ^ p3) & 0xffffffff
        s.index = 0

    iVar1 = s.index
    s.index = iVar1 + 1
    uVar2 = (s.state[iVar1] ^ z3.LShR(s.state[iVar1], 0xb)) & 0xffffffff
    uVar2 = (uVar2 ^ (uVar2 << 7) & 0x9d2c5680) & 0xffffffff
    uVar2 = (uVar2 ^ (uVar2 << 0xf) & 0xefc60000) & 0xffffffff
    rand_num =  (uVar2 ^ z3.LShR(uVar2, 0x12)) & 0xffffffff

    return s, rand_num


seed = z3.BitVec('seed', 32)

s = State()
s = m_seedRand(s, seed)
for _ in range(0, 1000):
    s, n = gerRandLong(s)
s, n = gerRandLong(s)

solver = z3.Solver()
solver.add(n == 0xa682f49) # <- VALUE HERE

embed()